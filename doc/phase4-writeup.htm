<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>CS 1653 Project P4 Writeup</title>
  <style>
/* BEGIN CHANGES HERE */

/* In this section, you may add CSS styling if desired */
@media screen {

  body {
      background: black;
      color: cornflowerblue;
  }

  .center {
    display: block;
    margin-left: auto;
    margin-right: auto;
  }

  .tablecenter {
    margin-left: auto;
    margin-right: auto;
  }

  figcaption {
    color: aquamarine;
  }

  h3 {
      color: coral;
  }

  h2 {
      color: coral;
  }

  h1 {
      color: crimson;
  }

  table, th, td {
    border: 1px solid cornflowerblue;
  }
}

header {
  text-align: center;
}  

table, th, td {
  border: 1px solid cornflowerblue;
}

.center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.tablecenter {
  margin-left: auto;
  margin-right: auto;
}

figcaption {
  text-align: center;
}

/* END CHANGES HERE */
  </style>
  <body>
    <header>
      <h1>CS 1653 Project P4 Writeup</h1>
      <h2>
<!-- BEGIN CHANGES HERE -->

Dane Halle dmh148@pitt.edu | Kyle O'Malley jko12@pitt.edu | Quinnan Gill qcg1@pitt.edu

<!-- END CHANGES HERE -->
      </h2>
    </header>
    <section id="overview">
      <h2>Overview</h2>
<!-- BEGIN CHANGES HERE -->

<p>
  The types of techniques we are utilizing in this phase are < SOMETHING FOR T5 @Q >, a form of Lazy Revocation where each group will generate new keys every time a user is removed and keep all the old keys in case they are needed, and < SOMETHING FOR T7 @Kyle >. These include use of counters and HMACs, symmetric cryptography using AES in CBC mode, and < something >.
</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="threat5">
      <h2>Threat T5: Message Reorder, Replay, or Modification</h2>
<!-- BEGIN CHANGES HERE -->

<p>
  Once a connection is established all communications are encrypted with AES-CBC; however no integrity is provided for the message. The attacker could modify the encrypted message bytes causing the data in the message to be unintelligible or worse incorrect. The attacker could also view the data and infer what commands are run. For example if the attacker knows that a bunch of data sent to the file server is an UPLOADF command, then the attacker could just send what they had just seen again but with some bytes changed. This could result in the file being overwritten with incorrect data invalidating the integrity of the file.
</p>

<p>
  To ensure integrity and semantic security is provided in the system, all information will be paired with an incrementing value (initially a nonce) and a HMAC of the message and nonce. Before the message is encrypted, a nonce will be generated and that message and nonce will be hashed into an HMAC. This will then be encrypted and sent to its intended recipient.
</p>

<figure>
  <img src="./images/T5.1.png" alt="T5.1" class="center">
  <figcaption>Diagram T5.1</figcaption>
</figure>

<p>
  The nonce will be continuously increased by 1 per message in the session to ensure that it is unique with each key and preventing any replay and reorder attacks. The client and the servers will have to maintain state to verify that the nonce is increasing and produce an error message when the nonce is not greater than the current value in the state. The client and servers will also need to verify the HMAC after every message received. This method will also be applied with EKE to ensure integrity in the key exchange between the client and the server.
</p>

<p>
  To provide integrity as well as confidentiality two keys must be derived from the processes seen in Diagram T5.2 and Diagram T5.3. But instead it will generate two different keys.
</p>

<figure>
  <img src="./images/T5.2.png" alt="T5.2" class="center">
  <figcaption>Diagram T5.2</figcaption>
</figure>

<figure>
  <img src="./images/T5.3.png" alt="T5.3" class="center">
  <figcaption>Diagram T5.3</figcaption>
</figure>

<p>
  After the key between the client and each of the servers is established, the integrity key will be generated by taking a SHA 2 hash of the derived key with the string “Integrity” and the key used to encrypt the message will be a SHA 2 hash of the derived key with the string “Confidentiality”. See Diagram T5.4 below for more information.
</p>

<table class="tablecenter">
  <tr>
    <th>Key Type</th>
    <th>Key Value (K = derived key)</th>
  </tr>
  <tr>
    <td>Integrity Key (K<sub>i</sub>)</td>
    <td>K<sub>i</sub> = SHA-256(“Integrity” || K)</td>
  </tr>
  <tr>
    <td>Confidentiality Key (K<sub>c</sub>)</td>
    <td>K<sub>c</sub> = SHA-256(“Confidentiality” || K)</td>
  </tr>
</table>

<p>
  The nonce will provide semantic security because it requires the nonce in each message to increase. If the attacker performs a replay or a reorder attack the client or server will notice that the nonce did not increase from its last stored value and thus invalidate the message. The key derivation will also prevent replay attacks or different servers because it is unique to each client/server session. If the attacker modifies the nonce, this will be detected by an invalid HMAC and the message will be ignored. The HMAC also provides integrity for the entire message. If the attacker modifies any bit of the transmission, even the HMAC, the comparison between the hashed nonce and message and the HMAC will be non equal. This will help detect any integrity violation of the transmission.
</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="threat6">
      <h2>Threat T6: File Leakage</h2>
<!-- BEGIN CHANGES HERE -->

<p>
  T6 is the threat of untrusted file servers leaking files to unauthorized principals. We must assume that there is no “out of bounds” communications between group and file servers as there is no way for the group server to know about all file servers that could exist within the system.  
</p>

<p>
  The approach we decided to go with is a mediated protocol. T6.1 will detail how UPLOADF will work in this new system and T6.2 will detail how DOWNLOADF will work with this new system. Each group will be initialized with a private key/secret. This key/secret will only change when a user is removed from the group. However, the group will store all previous keys with a unique identifier for each key. As well as the current key/identifier that should be used to encrypt new files. 
</p>

<figure>
  <img src="./images/T6.1.png" alt="T6.1" class="center">
  <figcaption>Diagram T6.1</figcaption>
</figure>

<p>
  Utilizing a new request for this phase, <code>CURKEY token groupname</code>, the user will request the most recent token for the given group from the group server. The group server will return the most recent token and the unique identifier associated with that key. The user will locally encrypt the given file with K<sub>ID</sub> and then send it to the File server along with their token, the dest_file (or file name/path on the server), the group that the file is associated with, and the key’s unique identifier to the File Server where the all the information will be stored as expected/normal. Should the File Server leak any files uploaded to it along with any information associated with it, there would need to be a leak within the group server or a client who is/was in the group in order for any meaningful information to be exposed. 
</p>

<figure>
  <img src="./images/T6.2.png" alt="T6.2" class="center">
  <figcaption>Diagram T6.2</figcaption>
</figure>

<p>
  The user will first communicate with the File server in order to get the encrypted file, ID, and group the encrypted file is associated with. The client will hold onto the encrypted file and send along their token, the group, and ID returned from the File Server in order to get the group key associated with that unique identifier using a new request for this phase, <code>KEYID token groupname ID</code>. Then the client will locally decrypt the file into the given dest_file (or local name/path on the client’s machine).
</p>

<p>
  The ID for the keys within a group server are an encoded string of the IV that is used for encryption and decryption of the files since the keys are AES-256 CBC. Once an ID is generated, along with an initialization step for key generation, that information is stored in a Hashtable within the Group subclass from GroupList. To ensure that any keys that are generated are not lost between different runs of a persistent Group Server, we now save the GroupList to its own GroupList.bin instead of parsing it from UserList like we were previously.
</p>

<p>
  This system works and is secure because it utilizes lazy revocation. Lazy revocation states that if a user was a bad actor, they could leak anything that they had access to and we cannot prevent that from happening other than removing the user from the group. Whenever a user is removed from a group, a new key and unique identifier are generated and will be used for all future encryptions on new files or until a user is removed from the group again. The downside to this system is that each group needs to store every key that has been generated since the existence of the group to ensure that any file uploaded to the file server at any point can be decrypted at any point in the future.
</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="threat7">
      <h2>Threat T7: Token Theft</h2>
<!-- BEGIN CHANGES HERE -->

<p>
  This threat is that a corrupted file server could steal a user’s token and give that token to another user to use on other file servers. We must create a mechanism that prevents a user from using a token that is not theirs on a file server that is not corrupted.
</p>

<p>
  We will do this using a similar mechanism used to protect against T2. We will modify the token to include two new fields, file server public key and a timestamp. Then every time the user makes a file server request, they will first request a refreshed token from the group server that includes the current timestamp and the file server public key of the file server they are making a request to. That refreshed token will be signed by the group server just like in T2 using their private key. Below is a visual refresher of how T2 works. In this iteration of our product we modified the order of the string encodings as well as hash the inputs using SHA-256 in order to ensure certain user input (such as group names like ‘ADMIN,everyone’) doesn’t give a user inaccurate accesses.
</p>

<figure>
  <img src="./images/T7.1.png" alt="T7.1" class="center">
  <figcaption>Diagram T7.1</figcaption>
</figure>

<p>
  Once the user gets this refreshed token with the timestamp, file server id, and group server signature, they will send all of that over to the file server they are making the request to. Once the file server gets that from the user, they will verify the token signature using the group server public key they got from the out of bounds operation in T2. They will then check if the timestamp is not over 10 minutes old. They will then check if the token’s file server public key matches its own public key.
</p>

<figure>
  <img src="./images/T7.2.png" alt="T7.2" class="center">
  <figcaption>Diagram T7.2</figcaption>
</figure>

<p>
  T7.2 gives a visual for the communications every time the user makes a file server request.
</p>

<p>
  This mechanism protects against token theft in multiple ways. Only the group server can sign the tokens, so if a user gets a hold of a stolen token they won’t be able to use it on a non corrupt file server since they don't have a way to spoof the group server signature. The timestamp prevents a user from using the stolen token on the same file server the request is being made on after a brief period of time.
</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="discussion">
      <h2>Discussion</h2>
<!-- BEGIN CHANGES HERE -->

<p>
  Within this phase, there isn’t as much interplay within our proposed mechanisms we proposed for this phase. However, there is quite a bit of interplay with our proposed and implemented mechanisms from phase 3. Notably, T5 has interplay with T1 and T3. T7 also has interplay with T2. 
</p>

<p>
  We approached this phase similar to phase 3 with whiteboarding and spitballing ideas for each threat. We talked about some different approaches and small ideas to mitigate each threat. One that evolved the most would be T6. Initially we discussed utilizing a form of Shamir’s Secret Sharing Scheme that would utilize RSA components. However, being that there were a lot of moving parts required and not being able to wrap our heads around how it would all work properly so we ended up going for a different approach. That leads to a system where users would have to upload files to the group server for encryption before sending them to the file server and decryption after receiving them from the file server. This approach had the benefit of ensuring that any unauthorized user could not decrypt leaked files from a file server and made key management quite easy as there would only need to be one per group. However, this system would impact “availability” quite significantly as any large load could cause the group server to crash and the system would require 3 upload/downloads of the files in order to perform one operation. 
</p>

<p>
  All implemented mechanisms directed at the threats from phase 3 are still valid. All implementations remain untouched in their raw implementations and functions. The only alterations that were made were for extending information utilized in these implementations for some other mechanism that was worked on for this phase. 
</p>

<p>
  <b>NOTE</b>: We realized that our write up for phase 3 was not entirely accurate to our implementation and have made changes to reflect what we implemented. Specifically, those changes are _______________________. 
</p>

<p>
  If your group did any extra credit, please discuss that in this section, as well.
</p>

<!-- END CHANGES HERE -->
    </section>
  </body>
</html>
