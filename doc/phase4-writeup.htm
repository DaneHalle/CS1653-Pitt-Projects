<html style="
    background: black;
    color: cornflowerblue;
"><!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>CS 1653 Project P4 Writeup</title>
  <style>
/* BEGIN CHANGES HERE */

/* In this section, you may add CSS styling if desired */
header {
  text-align: center;
}

.center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

figcaption {
  text-align: center;
  color: aquamarine;
}

h3 {
    color: coral;
}

h2 {
    color: coral;
}

h1 {
    color: crimson;
}

/* END CHANGES HERE */
  </style>
  <body>
    <header>
      <h1>CS 1653 Project P4 Writeup</h1>
      <h2>
<!-- BEGIN CHANGES HERE -->

Add your names and Pitt email addresses here

<!-- END CHANGES HERE -->
      </h2>
    </header>
    <section id="overview">
      <h2>Overview</h2>
<!-- BEGIN CHANGES HERE -->

<p>In this section, broadly overview the types of cryptographic techniques that
your group has decided to use to address threats T5–T7.</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="threat5">
      <h2>Threat T5: Message Reorder, Replay, or Modification</h2>
<!-- BEGIN CHANGES HERE -->

<p>
  Once a connection is established all communications are encrypted with AES-CBC; however no integrity is provided for the message. The attacker could modify the encrypted message bytes causing the data in the message to be unintelligible or worse incorrect. The attacker could also view the data and infer what commands are run. For example if the attacker knows that a bunch of data sent to the file server is an UPLOADF command, then the attacker could just send what they had just seen again but with some bytes changed. This could result in the file being overwritten with incorrect data invalidating the integrity of the file.
</p>

<p>
  To ensure integrity and semantic security is provided in the system, all information will be encrypted with a nonce and appended with a HMAC hash. Before the message is encrypted, a nonce will be generated and that message and nonce will be hashed into an HMAC. This will then be encrypted and sent to its intended recipient.
</p>

<figure>
  <img src="./images/T5.1.png" alt="T5.1" class="center">
  <figcaption>Diagram T5.1</figcaption>
</figure>

<p>
  As seen in Diagram T5.1, anything highlighted in red will be hashed to generate the HMAC. For the HMAC, a SHA-256 hash will be generated with the message and an opad of the key and then another SHA-256 hash will be generated from the first one’s output appended with the ipad of key. For more information on how the opad and ipad will be generated see source one below. The nonce will be continuously increased per message in the session to ensure that it is unique with each key and preventing any replay and reorder attacks. The client and the servers will have to maintain state to verify that the nonce is increasing. The client and servers will also need to verify the HMAC after every message received. This method will also be applied with EKE to ensure integrity in the key exchange between the client and the server.
</p>

<p>
  The nonce will provide semantic security because it requires the nonce in each message to increase. If the attacker performs a replay and reorder attack the client or server will notice that the nonce did not increase from its last stored value and thus invalidate the message. If the attacker modifies the nonce, this will be detected by an invalid HMAC and the message will be ignored. The HMAC also provides integrity for the entire message. If the attacker modifies any bit of the transmission, even the HMAC, the comparison between the hashed nonce and message and the HMAC will be non equal. This will help detect any integrity violation of the transmission.
</p>

<p>
  <i><b>Note: Need to add reorder attack with replay attack</b></i>
</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="threat6">
      <h2>Threat T6: File Leakage</h2>
<!-- BEGIN CHANGES HERE -->

<p>
  T6 is the threat of untrusted file servers leaking files to unauthorized principals. We must assume that there is no “out of bounds” communications between group and file servers as there is no way for the group server to know about all file servers that could exist within the system. 
</p>

<p>
  The approach we decided to go with is a mediated protocol. T6.1 will detail how DOWNLOADF will work in this new system and T6.2 will detail how UPLOADF will work with this new system. This entire system will be using a private key/secret that is generated by the group server when a group is made. The group server should not send this key/secret to anyone and any utilization of the key/secret will be done within the Group Server itself. 
</p>

<figure>
  <img src="./images/T6.1.png" alt="T6.1" class="center">
  <figcaption>Diagram T6.1</figcaption>
</figure>

<p>
  T6.1 details DOWNLOADF in a mediated protocol. The Client will first contact the File Server, who will have already been authenticated and authorized by our implementation to mitigate T3, and ask for the encrypted file associated with Remote File Name and then the Group. After receiving a response, the client will then talk to the Group Server and send their token, Group Name for the file, and the encrypted file. The group server will then return the unencrypted file to the client. 
</p>

<figure>
  <img src="./images/T6.2.png" alt="T6.2" class="center">
  <figcaption>Diagram T6.2</figcaption>
</figure>

<p>
  T6.2 details UPLOADF in a mediated protocol as well. The first thing the client does is send it’s token, the Group Name, and the file to the Group Server to get an encrypted File with the given group’s key. Then the client will send it’s token, the group name, the encrypted file, and the remote path to the File Server for upload. 
</p>

<p>
  This mechanism does not prevent file leakage from File Servers. However, it ensures that any files that do leak from the file servers are in a state where it is not possible to extract information on the leaked file. The reasoning for keeping the encryption/decryption within the Group Server as opposed to it being done client side is so that the client will not be able to keep the key/secret for a group to be utilized at a later date. The key/secret utilized will likely be an AES-256 key utilizing CBC for encryption/decryption.
</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="threat7">
      <h2>Threat T7: Token Theft</h2>
<!-- BEGIN CHANGES HERE -->

<p>
  This threat is that a corrupted file server could steal a user’s token and give that token to another user to use on other file servers. We must create a mechanism that prevents a user from using a token that is not theirs on a file server that is not corrupted.
</p>

<p>
  We will do this using a similar mechanism used to protect against T2. We will modify the token to include two new fields, file server id and a timestamp. Then every time the user makes a file server request, they will first request a refreshed token from the group server that includes the current timestamp and the file server id of the file server they are making a request to. With that token refresh the group server will sign that token just like in T2 using their private key.
</p>

<p>
  Once the user gets this refreshed token with the timestamp, file server id, and group server signature, they will send all of that over to the file server they are making the request to. Once the file server gets that from the user, they will verify the token signature using the group server public key they got from the out of bounds operation in T2. They will then check if the timestamp is not over 1 minute old. They will then check if the token’s file server ID matches its own file server id.
</p>

<figure>
  <img src="./images/T7.1.png" alt="T7.1" class="center">
  <figcaption>Diagram T7.1</figcaption>
</figure>

<p>
  T7.1 gives a visual for the communications every time the user makes a file server request.
</p>

<p>
  This mechanism protects against token theft in multiple ways. Only the group server can sign the tokens, so if a user gets a hold of a stolen token they won’t be able to use it on a non corrupt file server since they don't have a way to spoof the group server signature. The timestamp prevents a user from using the stolen token on the same file server the request is being made on after a brief period of time.
</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="discussion">
      <h2>Discussion</h2>
<!-- BEGIN CHANGES HERE -->

<p>Conclude with a paragraph or two discussing the interplay between your
proposed mechanisms, and commenting on the design process that your group
followed. Did you discuss other ideas that didn’t pan out before settling on the
above-documented approach? Did you end up designing a really interesting
protocol suite that addresses multiple threats at once? Use this space to show
off your hard work!</p>

<p>Finally, spend about one paragraph convincing me that your modified protocols
still address the threats T1–T4 described in Phase 3 of the project.</p>

<p>If your group did any extra credit, please discuss that in this section, as
well.</p>

<!-- END CHANGES HERE -->
    </section>
  </body>
</html>
